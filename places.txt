/*
================================================================================
== PLANNING: Setting Up Places =================================================

The owner of a location should be able to set up places there, but the concept 
of "owner" is sometimes an iffy one. Some games prefer that staff own all 
public hangouts, for example, even though a noncharbit has administrative 
control over it.

We'll store everything, including this optional 'places owner' lock, on a set of 
room attributes prefixed `&places.*` and keep controlled information locked to 
the places object.

	places.<num>.details: <name>|<spaces>|<description>
	places.<num>.notices: <say prefix>|<join>|<ojoin>|<depart>|<odepart>
	places.<num>.occupancy: <who's there>

(If 'spaces' is 0, no limit.)

If we get this far, lock to the places system object:

	places.administrators: <list of people who can set up places here>

User-defined commands we'll need:
(If your game does not have one of these, look for `&.<funcname>`)

	isstaff( <player> ) - return '1' if player has staff access

	header( <text> ) - game's default command header
	footer( <text> ) - game's default command footer
	divider() - minor divider
	wheader(), wdivider(), wfooter() - A width()-friendly version of the above

	titlestr( <string> ) - Display text as something like book-title appropriate


--------------------------------------------------------------------------------
-- Validations -----------------------------------------------------------------

The : and | characters are restricted as common output delimiters, and could 
mess up attribute setting.


--------------------------------------------------------------------------------
-- TO DO -----------------------------------------------------------------------

*** As-Needed Places (LA's "Gatherings") ***

You could, essentially, 'go stand next to' someone and it'd make the place 
spontaneously and other people could join it.

And it ceases to be when all are gone.

Same, but &gathering.* ( ? ) -- no, because the rest of the places system needs to 
be able to interface with it.

Instead: &place.<# of places + 1> and 
		 &_gatherings: <list of place numbers that are gatherings>


*** Evesdropping Staff ***

Extend '*.occupancy' to <at place>|<evesdropping> so 'tt' triggers for them, but 
join/leave does not. Be loud about evesdropping. Staff-only.


*** Dark Staff ***

Wiz-Inherit-Dark objects or dark staff are not detected or rejected and will 
notify the room.


================================================================================
== SETUP: Places ===============================================================
*/

@create Places Global Object <pgo>

@fo me=&d.pgo me=[search( name=Places Global Object <pgo> )]

@set pgo=Inherit Safe

@fo me=@parent [v( d.pgo )]=[search( name=Code Object Data Parent <codp> )]
&prefix.user_function_actions [v( d.pgo )]=action.


/*
--------------------------------------------------------------------------------
-- @adisconnect ----------------------------------------------------------------

Because TinyMUX and PennMUSH, as of this writing, don't have rooms checking 
@adisconnect for their contents, allowing only zones to do this, we're forced to 
do some mental gymnastics. We could override the room's @listen/@ahear, but I'd 
rather this clearner solution.

Using @eval so it only hits the command queue once, in unlikely fringe timing 
cases.

Using iter() to catch all rooms needing cleaned. Again unlikely, but there.

*/

@adisconnect [v( d.pgo )]=
	@eval 
		iter( 
			search( eroom=grep( ##, places.*.occupancy, %# )), 
			ulocal( ufunc/privileged.places, depart, ##, %# )
		)


/*
================================================================================
== PLACES GLOBAL OBJECT <pgo> ==================================================

Commands:

	places - the main driving command
	tt[ooc] - tabletalk - : ; | "
	join & depart - there we go

NOTE TO SELF: I think the 'mutter' commands try to integrate with the places 
systems. Remember to check and fix accordingly.


================================================================================
== DATA ========================================================================


--------------------------------------------------------------------------------
-- Element Defaults ------------------------------------------------------------

If a places element is not set, or while setting up, use these defaults.

*/

&d.default.name [v( d.pgo )]=a table
&d.default.spaces [v( d.pgo )]=5
&d.default.description [v( d.pgo )]=A table with a couple of chairs.

&d.default.say_prefix [v( d.pgo )]=At your table
&d.default.join [v( d.pgo )]=You join #NAME.
&d.default.ojoin [v( d.pgo )]=joins at #NAME (##LOC).
&d.default.depart [v( d.pgo )]=You depart #NAME.
&d.default.odepart [v( d.pgo )]=departs #NAME (##LOC).


/*
================================================================================
== COMMAND SETUP ===============================================================

The "Mistress System" funnels everything through a single command. For this command, like many others, an optional 's' on it is valid. e.g., place/places.

	+command(s) -> &c.<command>.default
	+command(s) <stuff> -> &c.<command>.specific
	+command(s)/switches [<stuff>] -> &c.<command>/<switch>

To each of these ( including the first ), the following are passed:
	%0: <stuff>
	%1: </other/switches>

In the case of the switches, the first valid switch has their command called, if all switches are invalid we call &c.<name>.default or &c.<name>.specific, depending on the above rules.

(?s) in pcre: A mode modifier that enables dot-matching the newlines.

*/

&c.places [v( d.pgo )]=$(?s)^\+?places?(.*)$:
	@eval setq( n, places ); 

	@pemit %#=
		switch( strtrunc( %1, 1 ), 
			@@( null ), u( c.%qn.default ), 
			/, u( c.%qn.switch, first( %1 ), rest( %1 )), 
			%b, u( c.%qn.specific, trim( %1 )), 
			error
		)

// --

@set v( d.pgo )/c.places=regex


/*
--------------------------------------------------------------------------------
-- places/<switch> -------------------------------------------------------------

Handles all /switches, which is to say it makes sure they exist and passes them 
on.

Also handles pseudo-switches, passing them on as elements to any switched item.

Passes to `&c.<name>.specific` (%1, %qp) or `&c.<name>/<switch>` (%1, %qp), 
even if %1 is empty.

--

0: /<switch>[/<switch>/<switch>, etc.]
1: [<more>], stuff to pass to c.<name>/<switch>, if any
qn: Name of the command, global register set in &c.<name> (above)

qa: all c.<name>/* on this object
qs: /valid/command/switches/found
qp: /pseudo/switches/found, pass to c.<name>[/<switch>]

*/

&c.places.switch [v( d.pgo )]=
	strcat( 
		setq( s, ), setq( p, ), 
		setq( a, lattr( %!/c.%qn/* )), 
		iter( rest( %0, / ), 
			if( 
				t( grab( %qa, c.%qn/%i0* )), 
				setq( s, %qs/[rest( grab( %qa, c.%qn/%i0* ), / )] ), 
				setq( p, %qp/%i0 )
			), 
			/, @@ 
		), 
		if( t( %qs ), 
			ulocal( c.%qn/[extract( %qs, 2, 1, / )], %1, %qp ), 
			if( t( %1 ), 
				ulocal( c.%qn.specific, %1, %qp ), 
				ulocal( c.%qn.default, %1, %qp )
			)
		)
	)


/*
--------------------------------------------------------------------------------
-- places (default) ------------------------------------------------------------

Show default places setup.

>> REFUSE TO WORK IF ROOM IS SET HALT <<

Because of the @aleave/@startup that's placed on a room, if it's set halt then the cleanup code won't work properly. Annoy people to unset it.

--

0: ignored
1: fake /switches, ignored

ql: location of %#

*/

&c.places.default [v( d.pgo )]=
	case( 0, 
		not( hasflag( loc( %# ), HALT )), 
		u( .msg, places, Places cannot work while the room is set HALT ), 

		attrcnt( [setr( l, loc( %# ))]/places.1.details ), 
		u( .msg, places, Places not configured ), 

		list( 
			lattr( %ql/places.*.details ), 
			u( f.display.one-place-brief, %ql, elements( %i0, 2, . ))
		)
	)


/*
--------------------------------------------------------------------------------
-- places <stuff> (specific) ---------------------------------------------------

Show information about a particular place

>> REFUSE TO WORK IF ROOM IS SET HALT <<

Because of the @aleave/@startup that's placed on a room, if it's set halt then the cleanup code won't work properly. Annoy people to unset it.

--

0: place name or number
1: fake /switches, ignored

ql: location of %#
qn: number of location, if name or #<num> passed

*/

&c.places.specific [v( d.pgo )]=
	case( 1, 
		hasflag( loc( %# ), HALT ), 
		u( .msg, places, Places cannot work while the room is set HALT ), 

		not( attrcnt( [setr( l, loc( %# ))]/places.1.details )), 
		u( .msg, places, Places not configured ), 

		cand( 
			isint( setr( n, if( strmatch( %0, #* ), rest( %0, # ), %0 ))), 
			hasattr( %ql, places.%qn.details )
		), 
		u( f.display.one-place-detailed, %ql, %qn ), 
		
		and( 
			t( setr( n, u( f.get-num-by-name, %ql, %0 ))), 
			hasattr( %ql, places.%qn.details )
		), 
		u( f.display.one-place-detailed, %ql, %qn ), 

		u( .msg, places, I can't find that place )
	)


/*
--------------------------------------------------------------------------------
-- places/configure ------------------------------------------------------------

	places/configure <location>[/<number>][=YES]

'here' should work fine.

--

qf: places() function results
ql: location for places
qn: number of places the player wants configured ( always 1 )

*/

&c.places/configure [v( d.pgo )]=
	case( 0, 
		not( comp( rest( %0, = ), YES )), 
		u( .msg, places/confugure, 
			Please take note! Configuring up places will overwrite the room's 
			@startup%, @ahear and @aleave attributes. If the room has places set 
			up already%, the existing places will be left but these attributes 
			will still be overwritten. If you are alright with this%, please 
			type: [ansi( h, places/configure [before( %0, = )]=YES )], 
		), 

		t( setr( f, 
			ulocal( ufunc/privileged.places, 
				configure, 
				before( before( %0, = ), / ), 
				YES, 
				rest( before( %0, = ), / )
			)
		)), 
		u( .msg, places/configure, titlestr( rest( %qf ))), 

		u( .msg, places/configure, Configured! )
	)


/*
--------------------------------------------------------------------------------
-- places/breakdown ------------------------------------------------------------

	places/breakdown <location>[=YES]

qf: places() function results

*/

&c.places/breakdown [v( d.pgo )]=
	case( 0, 
		not( comp( rest( %0, = ), YES )), 
		u( .msg, places/breakdown, 
			Please take note! Breaking down places will delete the room's 
			@startup%, @ahear and @aleave attributes%, as well as the attributes 
			set up to make places work. If you are alright with this%, please 
			type: [ansi( h, places/breakdown <location>=YES )] 
		), 

		t( setr( f, 
			ulocal( ufunc/privileged.places, breakdown, first( %0, = ), YES )
		)), 
		u( .msg, places/breakdown, titlestr( rest( %qf ))), 

		u( .msg, places/breakdown, Breakdown Complete! )
	)


/*
--------------------------------------------------------------------------------
-- places/newplace -------------------------------------------------------------

	places/newplace [<location>, <placenum>, <location>=<placenum>, or nothing]

qf: places() function results

*/

&c.places/newplace [v( d.pgo )]=
	case( 0, 
		t( setr( f, 
			ulocal( ufunc/privileged.places, 
				newplace, 
// .. find location
				case( 1, 
					strmatch( %0, *=* ), trim( first( %0, = )), 
					or( isint( %0 ), strmatch( trim( %0 ), )), loc( %# ), 
					%0
				), 
// .. placenum
				case( 1, 
					strmatch( %0, *=* ), trim( rest( %0, = )), 
					isint( %0 ), %0, 
					@@( pass null for 'next place' )
				)
			)
		)), 
		u( .msg, places/newplace, titlestr( rest( %qf ))), 

		u( .msg, places/newplace, Created place number %qf )
	)


/*
--------------------------------------------------------------------------------
-- places/delplace -------------------------------------------------------------

	places/delplace [<location>=]<placenum>

qf: places() function results

*/

&c.places/delplace [v( d.pgo )]=
	case( 0, 
		t( setr( f, 
			ulocal( ufunc/privileged.places, 
				delplace, 
				if( strmatch( %0, *=* ), trim( first( %0, = )), loc( %# )), 
				if( strmatch( %0, *=* ), trim( rest( %0, = )), %0 )
			)
		)), 
		u( .msg, places/delplace, titlestr( rest( %qf ))), 

		u( .msg, places/delplace, Deleted place number %qf )
	)


/*
--------------------------------------------------------------------------------
-- places/compress -------------------------------------------------------------

Moves the places together, filling any gaps. Does not correlate to a places() 
function, so do the normal set of access & validation checks. Staff or owner 
only.

	places/compress [<location>]

ql: location dbref
qn: new place numbers list, <old>:<new> <old>:<new> <old>:<new>
qo: output from

*/

&c.places/compress [v( d.pgo )]=
	case( 0, 
		or( 
			strmatch( 
				setr( l, if( setr( l, locate( %#, %0, ha )), %ql, loc( %# ))), 
				loc( %# )
			), 
			u( .isstaff, %# )
		), 
		u( .msg, places/compress, Compress at location only ), 

		strmatch( type( %ql ), ROOM ), 
		u( .msg, places/compress, Room not found ), 

		hasattr( %ql, places.1.details ), 
		u( .msg, places/compress, Places Not Configured ), 

// .. set the oldkey:newkey list
		[setq( n, 
			iter( 
				ulocal( ufunc/privileged.places, list, %ql ), 
				[first( %i0, : )]:[inum()], 
				|
			)
		)]
// .. move those that need it
		[u( .msg, places/compress, Compressed )]
		[u( .crumple, iter( %qn, 
			if( neq( first( %i0, : ), rest( %i0, : )), 
				[null( trigger( %!/tr.moveplace, 
					%ql, 
					first( %i0, : ), 
					rest( %i0, : )
				))]
				[first( %i0, : )]->[rest( %i0, : )]
			)
		))]
	)


/*
--------------------------------------------------------------------------------
-- places/cleanup --------------------------------------------------------------

	places/cleanup [<location>]

*/

&c.places/cleanup [v( d.pgo )]=
	case( 0, 
		t( setr( f, 
			ulocal( ufunc/privileged.places, 
				cleanup, if( t( %0 ), %0, loc( %# ))
			)
		)), 
		u( .msg, places/cleanup, titlestr( rest( %qf ))), 

		u( .msg, places/cleanup, Cleaned. )
	)


/*
--------------------------------------------------------------------------------
-- places/set ------------------------------------------------------------------

The general command to change information about a place.

	places/set [<loc>] <placenum>/<element>=<info>

ql: location dbref
qp: placenum
qe: element - name completion please, reject 'occupancy' here
qi: info

qf: function result

*/

&c.places/set [v( d.pgo )]=
	[setq( p, first( %0, / ))]
	[if( isint( %qp ), 
		setq( l, loc( %# )), 
		[setq( l, trim( revwords( rest( revwords( %qp )))))]
		[setq( p, trim( last( %qp )))]
	)]
	[setq( e, rest( first( %0, = ), / ))]
	[setq( e, last( first( lattr( %!/f.set.%qe* )), . ))]
	[setq( i, rest( %0, = ))]

	[case( 0, 
		not( strmatch( %qe, occupancy )), 
		u( .msg, places/set, 
			Please use 'places/cleanup [first( first( %0 ), / )]'
		), 

		t( setr( f, 
			ulocal( ufunc/privileged.places, set, %ql, %qp, %qe, %qi )
		)), 
		u( .msg, places/set, [rest( titlestr( %qf ))] ), 

		u( .msg, places/set, Set #%qp '[lcstr( %qe )]' to '%qi'. ) 
	)]



/*
================================================================================
== OTHER COMMANDS ==============================================================

These are the commands that alias to or don't use 'places'.


--------------------------------------------------------------------------------
-- join ------------------------------------------------------------------------

Join a place

	join [ at| with] <placenum, placename, or person>

0: matched command (ignore)
1: ' at'/' with' match
2: #<stuff>, if exists (ignore)
3: <place>|<person> match

qa: place number if 'at'
qw: place number if 'with'
qd: object dbref if 'with'
qt: register of place number (a/w/null)

qf: places() function results

*/

&c.join [v( d.pgo )]=$^join( at| with)?( #?(.*))?$:
// >> if nothing but 'join', fail
	@assert t( %3 )={ @pemit %#=u( .msg, places, Join where? }; )
	@assert not( ulocal( ufunc/privileged.places, whichplace, loc( %# ), %# ))={ 
		@pemit %#=
			u( .msg, places, You're already at a place. Please 'depart' first. )
	}; 

// >> guess for explicit/implicit 'at' or 'with'
	@eval case( 1, 
// .. explicit 'at'
		strmatch( %1, %bat ), 
		[setq( t, a )]
		[setq( a, if( 
			isint( %3 ), 
			trim( %3 ), 
			u( f.get-num-by-name, loc( %# ), %3 )
		))], 

// .. explicit 'with'
		strmatch( %1, %bwith ), 
		[setq( t, w )]
		[setq( w, 
			u( f.get-num-by-player, loc( %# ), setr( d, locate( %#, %3, nP )))
		)], 

// .. implicit 'at' (join <number>)
		isint( %3 ), [setq( t, a )][setq( a, trim( %3 ))], 

// .. implicit 'with' (join <neighbor name>)
		t( setr( d, locate( %#, %3, nP ))), 
		[setq( w, u( f.get-num-by-player, loc( %# ), %qd ))]
		[setq( t, w )], 

// .. implicit 'at' ( join <place name> )
		t( setr( a, u( f.get-num-by-name, loc( %# ), %3 ))), setq( t, a ), 

// .. panic condition
		setq( t, )
	); 

// >> start actual process
	@pemit %#=
		case( 0, 
			comp( %qt, ), 
			u( .msg, places, I can't figure out where you want to join. ), 

			comp( %#, %qd ), 
			u( .msg, places, You can't join yourself! ), 

			lte( words( r( %qt )), 1 ), 
			u( .msg, places, Too many matches. ), 

			words( r( %qt )), 
			u( .msg, places, 
				case( %qt, a, No such place, w, Not at a place )
			), 

			t( setr( f, 
				ulocal( ufunc/privileged.places, join, loc( %# ), r( %qt ), %# )
			)), 
			u( .msg, places, [rest( titlestr( %qf ))] ), 

			@@( If things go well places() will notify everyone )
		)

// --

@set v( d.pgo )/c.join=regexp


/*
--------------------------------------------------------------------------------
-- depart ----------------------------------------------------------------------

Leave a place

	depart

In the future: depart[ for [#]<place/player>]

qf: places() function results

*/

&c.depart [v( d.pgo )]=$^depart( for #?(.*))?$:
	@assert t( ulocal( ufunc/privileged.places, whichplace, loc( %# ), %# ))={ 
		@pemit %#=
			u( .msg, places, You're not at a place. Please 'join' first. )
	}; 

	@pemit %#=case( 0, 
		t( setr( f, ulocal( ufunc/privileged.places, depart, loc( %# ), %# ))), 
		u( .msg, places, rest( titlestr( %qf ))), 

		@@( If things go well places() will notify everyone )
	)

// -- 

@set [v( d.pgo )]/c.depart=regexp


/*
--------------------------------------------------------------------------------
-- tt: tabletalk ---------------------------------------------------------------

The basic unit of places are for conversation.

	tt[o[oc]] <say/pose/emit>

--

0: entire grab (ignore)
1: 'o' if tto[oc]
2: 'oc' if there (ignore)
3: ' <say/pose/emit>'

qn: place number person is at
qf: places() function results

*/

&c.tt [v( d.pgo )]=$(?s)^tt(o(oc)?)?(.*)?$:
	@assert strlen( trim( %3 ))={ 
		@pemit %#=
			u( .msg, places, You need to 'tt <something>'. )
	}; 

	@assert t( ulocal( ufunc/privileged.places, whichplace, loc( %# ), %# ))={ 
		@pemit %#=
		u( .msg, places, You're not at a place. Please 'join' first. ) 
		}; 

	@pemit %#=
		case( 0, 
			t( setr( f, 
				ulocal( ufunc/privileged.places, 
					tt, loc( %# ), %#, trim( %3 ), if( t( %1 ), ooc )
				)
			)), 
			u( .msg, places, rest( titlestr( %qf ))), 

			@@( If things go well places() will notify everyone )
		)

// --

@set [v( d.pgo )]/c.tt=regexp


/*
================================================================================
== LEGACY COMMANDS =============================================================

These are commands that are aliased from the old places system to the new, or a 
notice that the command no longer works.

*/

&c.old.plook [v( d.pgo )]=$plook*:
	@pemit %#=case( 1, t( %0 ), u( c.places.specific, trim( %0 )), 
	u( c.places.default ))

&c.old.sit [v( d.pgo )]=$sit*:
	@if hasflag( %#, HALT )=
	{ @pemit %#=u( .msg, sit, While you are set HALT please use 'join'. ) }, 
	{ @force %#=join%0 }

&c.old.leave [v( d.pgo )]=$leave*:
	@if hasflag( %#, HALT )=
	{ @pemit %#=
		u( .msg, leave, While you are set HALT please use 'depart'. )
	}, 
	{ @force %#=depart%0 }

&c.old.stand [v( d.pgo )]=$stand*:
	@if hasflag( %#, HALT )=
		{ @pemit %#=
			u( .msg, stand, While you are set HALT please use 'depart'. )
		}, 
		{ @force %#=depart%0 }

&c.old.mv [v( d.pgo )]=$mv from*:
	@pemit %#=u( .msg, places, 
		Moving vacancies for places has been deprecated. Please ask the room 
		owner to add more places to this location. 
	)

&c.old.update [v( d.pgo )]=$update */*=*:
	@pemit %#=u( .msg, places, 
		Update has been deprecated. Please use 'place/set'. 
	)

&c.old.configure [v( d.pgo )]=$configure * places:
	@pemit %#=u( .msg, places, 
		Configure has been deprecated. Please use 'places/configure'. 
	)

&c.old.unconfigure [v( d.pgo )]=$unconfigure places:
	@pemit %#=u( .msg, places, 
		Unconfigure has been deprecated. Please use 'places/breakdown'. 
	)


/*
================================================================================
== FUNCTION: Room Owner Permission =============================================

This function is used to detemine if someone has permission to configure, set, or delete places in a particular room.

It's separated out for the ease of adding other types of rooms and locations, e.g. for setting places on a temproom someone has themselves created.

--

0: dbref of enactor
1: dbref of room

*/

&f.permission.room_owner [v( d.pgo )]=
	cor( strmatch( %0, owner( %1 )), u( .isstaff, %0 ))

/*

To allow places in 'temprooms':

&d.temprooms_master [v( d.pgo )]=#1224

&f.permission.room_owner [v( d.pgo )]=
	cor( 
		strmatch( %0, owner( %1 )), 
		u( .isstaff, %0 ), 
		strmatch( %0, elements( get( v( d.temprooms_master )/room.%1 ), 5, . ))
	)

*/


/*
================================================================================
== FUNCTION: Get XXX ===========================================================

A bunch of functions to get specific information. An easy way to get information for current and future coding.

	u( f.get, <loc>, <placenum>, <list|of|elements> )
	u( f.get.<element>, <loc>, <placenum>, <element> )

--

The cleanup on &f.get.occupancy may require a little explanation:

In Tiny code, back to TinyMUSH 1.6, movement with the /quiet switch, 
such as @teleport/quiet, will avoid triggering a room's @aleave. 
In order to sidestep the cleanup issue, we'll make every action that
lists a location clean up the places. This will cause some extra overhead
and is excessive, but easy.

If it becomes a problem, start fixing it here.

*/

&f.get [v( d.pgo )]=
	iter( %2, udefault( first( lattr( %!/f.get.%i0* )), #-1, %0, %1 ), |, | )

&f.get.name [v( d.pgo )]=u( f.get-element, %0, details, %1, 1, %2, name )
&f.get.spaces [v( d.pgo )]=u( f.get-element, %0, details, %1, 2, %2, spaces )
&f.get.description [v( d.pgo )]=u( f.get-element, %0, details, %1, 3, %2, description )

&f.get.say_prefix [v( d.pgo )]=elements( get( %0/places.%1.notices ), 1, | )
&f.get.join [v( d.pgo )]=u( f.get-element, %0, notices, %1, 2, %2, join )
&f.get.ojoin [v( d.pgo )]=u( f.get-element, %0, notices, %1, 3, %2, ojoin )
&f.get.depart [v( d.pgo )]=u( f.get-element, %0, notices, %1, 4, %2, depart )
&f.get.odepart [v( d.pgo )]=u( f.get-element, %0, notices, %1, 5, %2, odepart )

&f.get.occupancy [v( d.pgo )]=
	strcat( null( ulocal( action.cleanup, %0 )), get( %0/places.%1.occupancy ))

/*

0: dbref
1: attribtue data is on
2: place num
3: location in attribute
4: name of item (for pulling default)

*/

&f.get-element [v( d.pgo )]=
	localize( 
		[setq( e, elements( get( %0/places.%2.%1 ), %3, | ))]
		[if( strlen( %qe ), objeval( %0, s( %qe )), v( d.default.%4 ))]
	)


/*
--------------------------------------------------------------------------------
-- Function: Get Num By Name ---------------------------------------------------

Slightly related, getting the number for a particular named place is critical. 
Normally I use the name for the key, but for this system we're using the place
number.

Cheap filter(). Returns all matches, unordered - lets calling code decide what to do with it.

	u( f.get-num-by-name, <location>, <place name> )

0: room dbref
1: name

*/

&f.get-num-by-name [v( d.pgo )]=
	iter( 
		lattr( %0/places.*.details ), 
		if( 
			strmatch( first( get( %0/%i0 ), | ), %1* ), 
			elements( %i0, 2, . )
		)
	)


/*
--------------------------------------------------------------------------------
-- Function: Get Num By Player -------------------------------------------------

Pulls the numbers of all locations a particular dbref is at.

	u( f.get-num-by-player, <location>, <player dbref> )

*/

&f.get-num-by-player [v( d.pgo )]=
	iter( 
		filter( fil.player-at-place, 
			lattr( %0/places.*.occupancy ), , , %0, %1 
		), 
		elements( %i0, 2, . )
	)


/*
--------------------------------------------------------------------------------
-- Filter: Player At Place -----------------------------------------------------

think filter( v( d.pgo )/fil.player-at-place, lattr( here/places.*.occupancy ), , , %L, %! )

*/

&fil.player-at-place [v( d.pgo )]=t( match( get( %1/%0 ), %2 ))



/*
================================================================================
== FUNCTION: Set XXX ===========================================================

Replaces elements entirely. No checking first; using this on a place that hasn't been set up first will cause the information to not be written, due to the nature of replace() on TinyMUX ( does not create, only replaces ).

	u( f.set.<element>, <loc>, <placenum>, <item> )

*/

&f.set.name [v( d.pgo )]=trigger( %!/tr.set-element, %0, details, %1, 1, %2 )
&f.set.spaces [v( d.pgo )]=trigger( %!/tr.set-element, %0, details, %1, 2, %2 )
&f.set.description [v( d.pgo )]=trigger( %!/tr.set-element, %0, details, %1, 3, %2 )

&f.set.say_prefix [v( d.pgo )]=trigger( %!/tr.set-element, %0, notices, %1, 1, %2 )
&f.set.join [v( d.pgo )]=trigger( %!/tr.set-element, %0, notices, %1, 2, %2 )
&f.set.ojoin [v( d.pgo )]=trigger( %!/tr.set-element, %0, notices, %1, 3, %2 )
&f.set.depart [v( d.pgo )]=trigger( %!/tr.set-element, %0, notices, %1, 4, %2 )
&f.set.odepart [v( d.pgo )]=trigger( %!/tr.set-element, %0, notices, %1, 5, %2 )

// .. "occupancy" sets without a trigger to avoid timing issues w/'tt'
// .. "cleanup" after for the same reason as &f.get.occupancy, above

&f.set.occupancy [v( d.pgo )]=
	strcat( 
		set( %0, places.%1.occupancy:%2 ), 
		trigger( %!/tr.chown, %0, places.%1.occupancy ), 
		null( ulocal( action.cleanup, %0 ))
	)


/*
--------------------------------------------------------------------------------
-- Trigger: Set Element --------------------------------------------------------

0: dbref
1: attribtue data is on
2: place num
3: location in attribute
4: new value

*/

&tr.set-element [v( d.pgo )]=
	&places.%2.%1 %0=replace( get( %0/places.%2.%1 ), %3, %4, | ); 
	@trigger %!/tr.chown=%0, places.%2.%1; 

&tr.set-direct [v( d.pgo )]=&%1 %0=%2; @trigger %!/tr.chown=%0, places.%2.%1; 



/*
================================================================================
== FUNCTION: Validate XXX ======================================================

Used primarially with &f.set.*, and should relate 1:1

	u( f.validate.<element>, <item> )

*/

&f.validate.text [v( d.pgo )]=
	case( 1, 
		regmatch( %0, :|%\| ), No pipes or colons., 
		cand( isint( %1 ), gt( strlen( %0 ), %1 )), Keep item to %1 characters 
	)

&f.validate.num [v( d.pgo )]=
	if( or( lt( %0, 0 ), not( isint( %0 ))), Positive integers only )

// --

&f.validate.name [v( d.pgo )]=u( f.validate.text, %0, 40 )
&f.validate.spaces [v( d.pgo )]=u( f.validate.num, %0 )
&f.validate.description [v( d.pgo )]=u( f.validate.text, %0 )

&f.validate.say_prefix [v( d.pgo )]=u( f.validate.text, %0, 30 )
&f.validate.join [v( d.pgo )]=u( f.validate.text, %0, 60 )
&f.validate.ojoin [v( d.pgo )]=u( f.validate.text, %0, 60 )
&f.validate.depart [v( d.pgo )]=u( f.validate.text, %0, 60 )
&f.validate.odepart [v( d.pgo )]=u( f.validate.text, %0, 60 )

&f.validate.occupancy [v( d.pgo )]=
	if( 
		land( iter( %0, and( isdbref( %i0 ), hastype( %i0, PLAYER )), , | ), | ), 
		Occupancy must be player dbrefs 
	)


/*
================================================================================
== DISPLAY: One Place, Brief ===================================================

Used by 'show me brief information about this place'

Returns:
	A Table (#1) has 1 empty place.
	 Present is: Thenomain

--

0: location dbref
1: place number

qi: information (name|spaces|occupancy)
qs: spaces (max)
qo: occupancy
qf: number of spaces free

*/

&f.display.one-place-brief [v( d.pgo )]=
	localize( 
		[setq( i, u( f.get, %0, %1, name|spaces|occupancy ))]
		[setq( s, elements( %qi, 2, | ))]
		[setq( o, last( %qi, | ))]

		[ansi( h, capstr( first( %qi, | )))] %(#%1%) has 
		[if( %qs, 
			[if( setr( f, sub( %qs, words( %qo ))), %qf, no )] 
			empty [u( .plural, %qf, place, places )], 
			no limit
		)].

		[if( words( %qo ), 
			%r%b Present is: 
			[itemize( iter( %qo, name( %i0 ), , | ), | )]
		)]
	)



/*
================================================================================
== DISPLAY: One Place, Detailed ================================================

Used by 'show me formatted information about this place'

Returns:
	A Table (#1) has 1 empty place.
	  Present is: Thenomain

--

0: location dbref
1: place number

qi: information (name|spaces|occupancy|description)
qs: spaces (max)
qo: occupancy
qd: description
qf: number of spaces free

*/

&f.display.one-place-detailed [v( d.pgo )]=
	localize( 
		[setq( i, u( f.get, %0, %1, name|spaces|occupancy|description ))]
		[setq( s, elements( %qi, 2, | ))]
		[setq( o, elements( %qi, 3, | ))]
		[setq( d, elements( %qi, 4, | ))]

		[u( .header, [titlestr( first( %qi, | ))] ( #%1 ))]%r
		%qd%r
		[u( .divider )]%r
		%b This place has 
		[if( %qs, 
			[if( setr( f, sub( %qs, words( %qo ))), %qf, no )] 
			empty [u( .plural, %qf, place, places )] out of %qs, 
			no occupancy limit
		)].

		[if( t( %qo ), 
			%r%b Present is: 
				[itemize( iter( %qo, name( %i0 ), , | ), | )]
		)]%r
	
		[u( .footer )]
	)



/*
================================================================================
== DISPLAY: Elements ===========================================================

The output of the various elements.


--------------------------------------------------------------------------------
-- Display Element -------------------------------------------------------------

Output any known element. Edit any tokens in the text.

0: dbref
1: place
2: element

*/

&f.display.element [v( d.pgo )]=
	edit( 
// .. get element - we know we'll get something if valid
		udefault( 
			f.display.element.%2, 
			u( f.display.element.other, %0, %1, %2 ), 
			%0, %1, %2
		), 
// .. replace tokens
		#LOC, %1, 
		#NAME, u( f.get.name, %0, %1 ), 
		#LCNAME, lcstr( u( f.get.name, %0, %1 ))
	)


/*
--------------------------------------------------------------------------------
-- Elements to display ---------------------------------------------------------
*/

&f.display.element.other [v( d.pgo )]=udefault( f.get.%2, #-1 Element Unknown, %0, %1 )

&f.display.element.occupancy [v( d.pgo )]=
	itemize( iter( u( f.get.occupancy, %0, %1 ), name( %i0 ), , | ), | )



/*
================================================================================
== TRIGGERS ====================================================================

Almost all the triggers on the object.


--------------------------------------------------------------------------------
-- Trigger: Chown --------------------------------------------------------------

Keep Your Room Tidy.

*/

&tr.chown [v( d.pgo )]=@chown %0/%1=[owner( %0 )]


/*
--------------------------------------------------------------------------------
-- Trigger: Configure ----------------------------------------------------------

The room configure functions. Since someone can run some of these multiple times, we'll unlock things that we lock first.

Setting up WILL clobber a room's @startup & @aleave and set it Monitor and !Halt

0: Our target room.

*/

&tr.configure [v( d.pgo )]=
	@unlock %0/places_listen; 
	@unlock %0/startup; 

	@aleave %0=@eval places%(depart, %%!, %%#%) ; 
	@startup %0=@eval places%(cleanup, %%!%) ; 

	@set %0=!halt; 

	@chown %0/aleave=[owner( %0 )]; 
	@chown %0/startup=[owner( %0 )]; 

	@lock %0/aleave=%0; 
	@lock %0/startup=%0; 


/*
--------------------------------------------------------------------------------
-- Trigger: Breakdown ----------------------------------------------------------

The places removal function.

This WILL clobber a room's @aleave and @startup

0: Our target room.

*/

&tr.breakdown [v( d.pgo )]=
	@unlock %0/aleave; 
	@unlock %0/startup; 

	@aleave %0=; @startup %0=; 

	@dolist [lattr( %0/places.* )]={ &## %0= }; 


/*
--------------------------------------------------------------------------------
-- Trigger: New Place ----------------------------------------------------------

Sets up Place #%1 in room %0 with all the defaults.

*/

&tr.newplace [v( d.pgo )]=
	&places.%1.details %0=
		[iter( name spaces description, v( d.default.%i0 ), , | )];
	&places.%1.notices %0=
		[iter( say_prefix join ojoin depart odepart, v( d.default.%i0 ), , | )]; 
	@chown %0/places.%1.details=[owner( %0 )]; 
	@chown %0/places.%1.notices=[owner( %0 )]; 


/*
--------------------------------------------------------------------------------
-- Trigger: Delete Place -------------------------------------------------------

Removes `Place #%1` in room `%0`.

*/

&tr.delplace [v( d.pgo )]=
	&places.%1.details %0=; 
	&places.%1.notices %0=; 
	&places.%1.occupancy %0=; 


/*
--------------------------------------------------------------------------------
-- Trigger: Move Place ---------------------------------------------------------

0: room dbref
1: old placenum
2: new placenum

*/

&tr.moveplace [v( d.pgo )]=
	@mvattr %0=places.%1.details, places.%2.details; 
	@mvattr %0=places.%1.notices, places.%2.notices; 
	@mvattr %0=places.%1.occupancy, places.%2.occupancy; 

	@chown %0/places.%2.details=[owner( %0 )]; 
	@chown %0/places.%2.notices=[owner( %0 )]; 
	@chown %0/places.%2.occupancy=[owner( %0 )]; 



/*
================================================================================
== FUNCTIONS: Support Functions ================================================

Some functions used for various different aspects of the system.


--------------------------------------------------------------------------------
-- Configurable Display Functions ----------------------------------------------

For cross-game compatability. Default message formatting goes here.

*/

&.isstaff [v( d.pgo )]=isstaff( %0 )
&.lmin [v( d.pgo )]=lmin( %0, %1 )
&.lmax [v( d.pgo )]=lmax( %0, %1 )
&.crumple [v( d.pgo )]=trim( squish( %0 ))
&.plural [v( d.pgo )]=if( eq( %0, 1 ), %1, %2 )

// -

&.msg [v( d.pgo )]=ansi( h, <%0>, n, %b%1 )

&.header [v( d.pgo )]=wheader( %0 )
&.footer [v( d.pgo )]=wfooter( %0 )
&.divider [v( d.pgo )]=wdivider( %0 )


/*
--------------------------------------------------------------------------------
-- Lowest Available Number -----------------------------------------------------

Passed a list of integers, it will return the lowest available positive integer.

0: list of values

*/

&f.lowest-available-number [v( d.pgo )]=
	u( .lmin, setdiff( lnum( 1, inc( u( .lmax, %0 ))), %0 ))


/*
================================================================================
== USER DEFINED FUNCTIONS: Support Functions ===================================

REMEMBER TO HOOK THIS INTO WHATEVER YOUR USER-DEFINED FUNCTION SETUP IS!


--------------------------------------------------------------------------------
-- places() --------------------------------------------------------------------

Rather than have one function per item, let's just have one function.

	places( <action>, <room> [, <other>] )

*/

&ufunc/privileged.places [v( d.pgo )]=
	[setq( l, locate( %#, %1, ahR ))]
	[if( cand( t( %ql ), hastype( %ql, ROOM )), 
		udefault( @@PLACES@@/action.%0, #-1 ACTION NOT FOUND, %ql, %2, %3, %4 ), 
		#-1 ROOM NOT FOUND 
	)]

// --

@startup [v( d.pgo )]=@function/privileged/preserve places=
	@@PLACES@@/ufunc/privileged.places

// --

@force me=@edit v( d.pgo )/ufunc/privileged.places=@@PLACES@@, [v( d.pgo )]
@force me=@edit v( d.pgo )/startup=@@PLACES@@, [v( d.pgo )]

/*
@force me=
	@edit [search( object=Places Global Object <pgo> )]/ufunc/privileged.places=
		@@PLACES@@, [search( object=Places Global Object <pgo> )]
@force me=
	@edit [search( object=Places Global Object <pgo> )]/startup=
		@@PLACES@@, [search( object=Places Global Object <pgo> )]


--------------------------------------------------------------------------------
-- places(): list --------------------------------------------------------------

List places in the room and who is at it, or list everyone in a certain place.

	places( list, <room> [, <place>] )

Returns: #-1 ERROR or '<num>:<name>:<max>:<list of dbrefs>', |-delim

*/

&action.list [v( d.pgo )]=
	localize( 
		case( 0, 
			cor( strmatch( %0, loc( %# )), u( .isstaff, %# )), 
			#-1 LIST MUST BE TRIGGERED IN ROOM, 

// >> check that it's set up
			hasattr( %0, places.1.details ), 
			#-1 PLACES NOT CONFIGURED, 

// >> no '<place>', return everything, may be null
			comp( %1, ), 
			sort( 
				iter( lattr( %0/places.*.details ), 
// .. less efficient than grabbing directly from attribute, more updatable 
					[setr( n, elements( %i0, 2, . ))]:
					[u( f.get.name, %0, %qn, name )]:
					[u( f.get.spaces, %0, %qn, spaces )]:
					[u( f.get.occupancy, %0, %qn )], 
					, |
				), 
				n, |, |
			), 

// >> rudamentary '<place>' check
			hasattr( %0, places.%1.details ), 
			#-1 NO SUCH PLACE, 

// >> 'else' assumption: place exists, so show it - start with cleanup
			%1:
			[u( f.get.name, %0, %1, name )]:
			[u( f.get.spaces, %0, %1, spaces )]:
			[u( f.get.occupancy, %0, %1 )]
		)
	)


/*
--------------------------------------------------------------------------------
-- places(): cleanup -----------------------------------------------------------

Cleanup is available only to the room itself, people in the room, 
or to a staffer.

NOTE: Remember to scan for/clean null "gatherings" when it's installed.
NOTE: See "places(): list", above, for when this code is called.

	places( cleanup, <room> [, <dbrefs to remove>] )

Returns: #-1 ERROR or 1 ( true ) if the code ran or set without error.

qp: player dbref

*/

&action.cleanup [v( d.pgo )]=
	localize( 
		case( 0, 
			cor( t( %1 ), or( strmatch( %0, loc( %# )), u( .isstaff, %# ))), 
			#-1 CLEANUP MUST BE USED IN ROOM, 

			cor( 
				strmatch( setr( p, pmatch( %1 )), %# ), 
				strmatch( %1, ), 
				u( .isstaff, %# )
			), 
			#-1 CLEANUP PLAYER MUST BE USED BY PLAYER, 

// no specific dbref( s ), clean up everyone
			t( %qp ), 
			[setq( c, lcon( %0, connect ))]
			[setq( e, 
				iter( lattr( %0/places.*.occupancy ), 
					set( %0, %i0:[setinter( get( %0/%i0 ), %qc )] ), , @@
				)
			)]
			[if( comp( %qe, ), 
				#-1 [ucstr( %qe )], 
				1
			)], 

// specific dbref( s ), clean up only them - even if they're connected
			[setq( e, 
				iter( lattr( %0/places.*.occupancy ), 
					set( %0, %i0:[setdiff( get( %0/%i0 ), %qp )] ), , @@
				)
			)]
			[if( comp( %qe, ), 
				#-1 [ucstr( %qe )], 
				1
			)]
		)
	)


/*
--------------------------------------------------------------------------------
-- places(): configure ---------------------------------------------------------

Configure (or re-configure) a room. Clobbers @startup, @aleave.

Must be used by room owner or staffer.

	places( configure, <room>, YES[, <number of places>] )

Returns: #-1 ERROR or 1 if it believes it was successful.

*/

&action.configure [v( d.pgo )]=
	case( 0, 
		u( f.permission.room_owner, %#, %0 ), 
		#-1 CONFIGURE MAY BE USED BY ROOM OWNER ONLY, 

		not( hasflag( %0, HALT )), 
		#-1 CONFIGURE CANNOT BE USED IF ROOM IS SET HALT, 

// >> validate 'number of places'
		cor( 
			not( strlen( %2 )), 
			and( isint( %2 ), lte( %2, 10 ), gte( %2, 1 ))
		), 
		#-1 CONFIGURE BETWEEN 1 AND 10 PLACES, 

// >> 'YES' was passed, do it
		comp( %1, YES ), 
		[trigger( %!/tr.configure, %0 )]
		[null( iter( lnum( 1, if( strlen( %2 ), %2, 1 )), 
			if( 
				not( hasattr( %0, places.%i0.details )), 
				trigger( %!/tr.newplace, %0, %i0 )
			)
		))]
		1, 

// >> else: no 'YES', show warning
		#-1 CONFIGURE REQUIRES CONFIRMATION
	)


/*
--------------------------------------------------------------------------------
-- places(): breakdown ---------------------------------------------------------

Remove places from a room permenantly. 

Clobbers @startup, @aleave.

	places( breakdown, <room> [, YES] )

Returns: #-1 ERROR or 1 if it believes it was successful.

*/

&action.breakdown [v( d.pgo )]=
	case( 0, 
		u( f.permission.room_owner, %#, %0 ), 
		#-1 BREAKDOWN MAY BE USED BY ROOM OWNER ONLY, 

// >> 'YES' was passed, do it
		comp( %1, YES ), 
		[trigger( %!/tr.breakdown, %0 )]
		1, 

// >> else: no 'YES', show warning
		#-1 BREAKDOWN REQUIRES CONFIRMATION
	)


/*
--------------------------------------------------------------------------------
-- places(): new place ---------------------------------------------------------

Create a new place, auto-incremented and filled with defaults.

	places( newplace, <room>, [<specific place number>] )

Returns: #-1 ERROR or place #, if successful.

qn: place number, for return & trigger

*/

&action.newplace [v( d.pgo )]=
	localize( 
		case( 0, 
			u( f.permission.room_owner, %#, %0 ), 
			#-1 SET MAY BE USED BY ROOM OWNER ONLY, 

			hasattr( %0, places.1.details ), 
			#-1 PLACES NOT CONFIGURED, 

			cor( not( strlen( %1 )), and( gte( %1, 1 ), isint( %1 ))), 
			#-1 PLACE NUMBER NOT VALID, 

			not( hasattr( %0, places.%1.details )), 
			#-1 PLACE ALREADY EXISTS, 

			[setr( n, 
				if( strlen( %1 ),
					%1, 
					u( f.lowest-available-number, 
						iter( 
							lattr( %0/places.*.details ), 
							elements( %i0, 2, . )
						)
					)
				)
			)]
			[trigger( %!/tr.newplace, %0, %qn )]
		)
	)


/*
--------------------------------------------------------------------------------
-- places(): del place ---------------------------------------------------------

Deletes a place, unless someone is already there.

	places( delplace, <room>, <specific place number> )

Returns: #-1 ERROR or ex-place #, if successful.

*/

&action.delplace [v( d.pgo )]=
	case( 0, 
		u( f.permission.room_owner, %#, %0 ), 
		#-1 SET MAY BE USED BY ROOM OWNER ONLY, 

		hasattr( %0, places.1.details ), 
		#-1 PLACES NOT CONFIGURED, 

		hasattr( %0, places.%1.details ), 
		#-1 PLACE NUMBER NOT VALID, 

		dec( %1 ), 
		#-1 CANNOT DELETE PLACE #1, 

		[null( u( action.cleanup, %0 ))]
		[not( hasattr( %0, places.%1.occupancy ))], 
		#-1 PLACE IS OCCUPIED, 

		%1
		[trigger( %!/tr.delplace, %0, %1 )]
	)


/*
--------------------------------------------------------------------------------
-- places(): set ---------------------------------------------------------------

Set an aspect of an existing place (including "gatherings", when exists).

	places( set, <room>, <place #>, <element> , <info> )

Info cannot be null.

qn: element name
qe: possible error during set

*/

&action.set [v( d.pgo )]=
	localize( 
		case( 0, 
			u( f.permission.room_owner, %#, %0 ), 
			#-1 SET MAY BE USED BY ROOM OWNER ONLY, 

// >> check that it's set up
			hasattr( %0, places.1.details ), 
			#-1 PLACES NOT CONFIGURED, 

// >> rudamentary '<place>' check
			hasattr( %0, places.%1.details ), 
			#-1 NO SUCH PLACE, 

// >> '<info> check
			comp( %3, ), 
			#-1 ELEMENT MAY NOT BE NULL, 

// >> '<element>' check - grab full item name & check null
			t( setr( n, 
				grab( 
					|[iter( lattr( %!/f.set.* ), last( %i0, . ), , | )], 
					%2*, |
				)
			)), 
			#-1 ELEMENT NOT FOUND, 

// >> '<element>' grabbed was null
			comp( %qn, ), 
			#-1 ELEMENT NOT FOUND, 

// >> validate input
			not( strlen( setr( e, u( f.validate.%qn, %3 )))), 
			#-1 [ucstr( %qe )], 

// >> set, check error from set
			comp( setr( e, u( f.set.%qn, %0, %1, %3 )), ), 
			1, 

			#-1 [ucstr( %qe )]
		)
	)


/*
--------------------------------------------------------------------------------
-- places(): join --------------------------------------------------------------

If I'm going to make this a function-based system, I might as well go all the way.

	places( join, <room>, <place #>, <player name or dbref> )

qp: dbref from pmatch()
qo: current place occupancy list
qs: spaces (max)
qe: possible error from set

*/

&action.join [v( d.pgo )]=
	localize( 
		case( 0, 
			cand( 
				strmatch( %0, loc( setr( p, pmatch( %2 )))), 
				cor( strmatch( %0, loc( %qp )), u( .isstaff, %# ))
			), 
			#-1 JOIN MUST BE TRIGGERED BY PLAYER FOR THAT ROOM, 

// >> check that it's set up
			hasattr( %0, places.1.details ), 
			#-1 PLACES NOT CONFIGURED, 

// >> if room is set halt, join/leave can't be cleaned up
			not( hasflag( %0, HALT )), 
			#-1 JOIN CANNOT BE USED IF ROOM IS SET HALT, 

// >> rudamentary '<place>' check
			hasattr( %0, places.%1.details ), 
			#-1 NO SUCH PLACE, 

// >> already there
			not( match( 
				setr( o, u( f.get.occupancy, %0, %1 )), 
				%qp
			)), 
			#-1 ALREADY AT THAT LOCATION, 

// >> already somewhere
			not( u( action.whichplace, %0, %qp )), 
			#-1 PLEASE DEPART BEFORE JOINING, 

// >> any space left? ( 0 spaces = infinite )
			or( 
				eq( setr( s, u( f.get.spaces, %0, %1 )), 0 ), 
				lt( words( %qo ), %qs )
			), 
			#-1 NO SPACES AVAILABLE, 

// >> dbref has to be player ( c.f. pmatch ), add it to .occupancy
			comp( setr( e, u( f.set.occupancy, %0, %1, trim( %qo %qp ))), ), 
// .. ojoin - sent to everyone but joiner
			[pemit( 
				setdiff( lcon( %0 ), %qp ), 
				[name( %qp )] [u( f.display.element, %0, %1, ojoin )]
			)]
// .. join - sent to joiner
			[pemit( 
				%qp, 
				u( f.display.element, %0, %1, join )
			)]
			1, 

// .. error found on set
			#-1 [ucstr( %qe )]
		)
	)


/*
--------------------------------------------------------------------------------
-- places(): whichplace --------------------------------------------------------

Which place# is someone in? Only available to person in that location. Returns the lowest numbered place, in the incorrect event that the person has joined more than one place. (This incorrect situation would get fixed via the leave/cleanup code.)

Be Careful: Whichplace has its own validation check. (If we check for dark players, here's where it should go.)

	places( whichplace, <loc>, <person> )

qn: place number (localized)

*/

&action.whichplace [v( d.pgo )]=
	localize( 
		case( 0, 
			cor( strmatch( setr( p, pmatch( %1 )), %# ), u( .isstaff, %# )), 
			#-1 WHICHPLACE MUST BE TRIGGERED BY TARGET, 

			t( setr( n, first( sort( u( f.get-num-by-player, %0, %qp ))))), 
			#-1 NOT AT ANY PLACE, 

			%qn
		)
	)


/*
--------------------------------------------------------------------------------
-- places(): nameplace ---------------------------------------------------------

Returns the place number of a place's name, the name -> num version of 'whichplace', but returns the place number of all matching places.

	places( nameplace, <loc>, <name> )

qn: place numbers (localized)

*/

&action.nameplace [v( d.pgo )]=
	localize( 
		case( 0, 
			cor( strmatch( %0, loc( %# )), u( .isstaff, %# )), 
			#-1 NAMEPLACE MUST BE USED IN ROOM, 

			t( setr( n, sort( u( f.get-num-by-name, %0, %1 )))), 
			#-1 NO MATCH, 

			u( .crumple, %qn )
		)
	)


/*
--------------------------------------------------------------------------------
-- places(): depart ------------------------------------------------------------

If I'm going to make this a function-based system, I might as well go all the way.

	places( depart, <room>, <player name or dbref> )

qp: dbref from pmatch()
qn: current place number

qo: new place occupancy list ( sans %qp )
qs: spaces ( max )
qe: possible error from set

*/

&action.depart [v( d.pgo )]=
	localize( 
		case( 0, 
			cor( strmatch( setr( p, pmatch( %1 )), %# ), u( .isstaff, %# )), 
			#-1 DEPART MUST BE TRIGGERED BY TARGET, 

// >> check that it's set up
			hasattr( %0, places.1.details ), 
			#-1 PLACES NOT CONFIGURED, 

// >> if room is set halt, join/leave can't be cleaned up
			not( hasflag( %0, HALT )), 
			#-1 DEPART CANNOT BE USED IF ROOM IS SET HALT, 

// >> check player is at a place - calls 'whichplace' - report #-1 ERROR
			t( setr( n, ulocal( action.whichplace, %0, %qp ))), 
			%qn, 

// >> if the character cleanup is okay...
			not( setr( e, u( action.cleanup, %0, %qp ))), 

// .. get who's left at that location ( edit probably redundant )
			[setq( o, edit( u( f.get.occupancy, %0, %qn ), %qp, ))]

// .. odepart - sent to everyone but departer
			[pemit( 
				setdiff( lcon( %0 ), %qp ), 
				[name( %qp )] [u( f.display.element, %0, %qn, odepart )]
			)]
// .. depart - sent to departer
			[pemit( 
				%qp, 
				u( f.display.element, %0, %qn, depart )
			)]
			1, 

// .. error from action.cleanup ( already has #-1 )
			%qe
		)
	)


/*
--------------------------------------------------------------------------------
-- places(): tt ----------------------------------------------------------------

	places( tt, <loc>, <person>, <msg>[, ooc] )

qp: dbref of target from pmatch()
qn: current place number

qo: current place occupancy list
qs: say/pose formatted

*/

&action.tt [v( d.pgo )]=
	localize( 
		case( 0, 
			cor( 
				strmatch( setr( p, pmatch( %1 )), %# ), 
				cand( strmatch( %0, loc( %# ))), u( .isstaff, %# )
			), 
			#-1 TT MUST BE USED IN ROOM BY PERSON, 

// >> check that it's set up
			hasattr( %0, places.1.details ), 
			#-1 PLACES NOT CONFIGURED, 

// >> if room is set halt, join/leave can't be cleaned up
			not( hasflag( %0, HALT )), 
			#-1 TT CANNOT BE USED IF ROOM IS SET HALT, 

// >> check player is at a place - calls 'whichplace'
			t( setr( n, ulocal( action.whichplace, %0, %qp ))), 
			%qn, 

// >> talk away
			[setq( o, u( f.get.occupancy, %0, %qn ))]
			[setq( p, name( %qp ))]
			[setq( s, 
				objeval( %#, switch( 
					%2, 
					:*, %qp [rest( %2, : )], 
					%;*, %qp[rest( %2, %; )], 
					|*, [rest( %2, | )] [ansi( xh, <from %qp> )], 
					"*, %qp says%, [rest( %2, " )], 
					%qp says%, %2
				))
			)]
			[case( 1, 
// .. >> staff evesdropping? (placeholder)

// .. >> ooc?
				strmatch( %3, ooc ), 
				pemit( %qo, 
					[u( f.display.element, %0, %qn, say_prefix )]%, 
					[ansi( xh, <ooc> )]%, %qs
				), 

// .. >> normal
				pemit( %qo, [u( f.display.element, %0, %qn, say_prefix )] %qs )
			)]
			1
		)
	)


/*
---------------------------------------------------------------------------------- places(): get ---------------------------------------------------------------

A complement to 'set' for people who want to have the place description added to the room description. Don't error if no such place, just return null. ( This is non-standard behavior, but more end-user friendly. )

	places( get, <loc>, <place>, <element> )

e.g., on @succ: places( get, %!, places( whichplace, %!, %# ), description )

qe: element from 'f.get'.

*/

&action.get [v( d.pgo )]=
	localize( 
		case( 0, 
			cor( strmatch( %0, loc( %# )), u( .isstaff, %# )), 
			#-1 GET MUST BE USED IN ROOM, 

// >> check that it's set up
			hasattr( %0, places.1.details ), 
			#-1 PLACES NOT CONFIGURED, 

// >> don't error if no such place, but do error if no such element
			comp( setr( e, u( f.get, %0, %1, %2 )), #-1 ), 
			#-1 NO SUCH ELEMENT, 

			%qe
		)
	)



/*
================================================================================
== HELP FILE ===================================================================

http://bitnmux.com/index.php/MUXhelp:Places


--------------------------------------------------------------------------------
-- Softcode Version ------------------------------------------------------------

// this is for a softcoded help system

&help~ic_commands~places xxx=
	Places: Virtual Locations~Places are virtual places to sit, stand or 
	occupy. You remain in the same room, but join a group of people within that 
	room who may or may not be having a quiet conversation only with others 
	placed with them. This may be different than the places code you're used to 
	(from AmberMUSH), but all attempts have been made to keep it similar while 
	updating.%rIn all instances, the 's' on 'places' is optional.%r%r%% [ansi( 
	h, Basic Commands )]%rTo use the system, you need to learn only these 
	commands.%r%r* [ansi( h, places )]: Who's here%r* [ansi( h, place <num or 
	name> )]: Information about that place.%r* [ansi( h, join <num or place name 
	or player name> )]: Go to a certain place.%r* [ansi( h, join at <num or 
	name> )]: Go to a specific place.%r* [ansi( h, join with <player> )]: Go to 
	where they are.%r* [ansi( h, depart )]: Leave your current place%r* [ansi( 
	h, tt <say/pose/emit> )]: Say or pose so only your place can hear. Can use 
	'|<text>' as a tt @emit.%r* [ansi( h, tto <say/pose> )]: OOC say or pose for 
	your place. 'ttooc' also works.%r* [ansi( h, place/cleanup \[<location>\] 
	)]: Clean up disconnected and left players. Cleaning up remotely is 
	staff-only.%r%r%% [ansi( h, Legacy Commands )]%rThese commands are to help 
	people familiar with the older 'places' system.%r%r* [ansi( h, plook )]: 
	Same as 'places'.%r* [ansi( h, plook <num or name> )]: Same as 'place <num 
	or name>%r* [ansi( h, sit )]: Same as 'join'%r* [ansi( h, stand%, leave )]: 
	Same as 'depart'%r%rFor configuration, see: [ansi( h, +help places 2 )]. For 
	examples, see: [ansi( h, +help places 5 )]~For the setup and administration 
	of places which may only be done by the room owner or staff. In all 
	instances, the 's' on 'places' is optional.%r%rWARNING: Places uses @startup 
	and @aleave on a room. If there is other code for those attributes, it will 
	need to be re-set after using places/setup and setup/breakdown. If the room 
	is set HALT, the following commands or switches won't work: places/setup, 
	join, depart, tt%r%r%% [ansi( h, Creating & Configuring Places )]%r* [ansi( 
	h, places/configure <location>\[/<number of places>\] )]%r%b Set places up 
	in this location. If <number of places> isn't set, it sets up a single 
	place. For most people, use the <location> of 'here'.%r* [ansi( h, 
	places/breakdown <location> )]%r%b Remove places from this location.%r* 
	[ansi( h, places/newplace \[<location>%, <placenum>%, 
	<location>=<placenum>%, or nothing\] )]%r%b Set up a new place, optionally 
	as <placenum>. If <location> is not used, assumes 'here'.%r* [ansi( h, 
	places/delplace \[<location>=\]<placenum> )]%r%b Removes place <num>. Place 
	'1' cannot be deleted. If <location> is not used, assumes 'here'.%r* [ansi( 
	h, places/compress \[<location>\] )]%r%b Removes any gaps in the list of 
	place numbers. Using <location> is staff-only.%r* [ansi( h, places/set 
	\[<location>\] <num>/<item>=<value> )]%r%b Set an <item> of a particular 
	place. If <location> is not used, assumes 'here'.%r%rFor the the places() 
	function, see: [ansi( h, +help places 4 )]. For examples, see: [ansi( h, 
	+help places 5 )]~The following are used with 'places/set' (see [ansi( h, 
	+help places 2 )]).%r%r%% [ansi( h, Items )]%rFor 'places/set', the 
	following items can be set. Partial names can be used, so 'desc' and 'say' 
	are both valid. None of these items may be empty.%r%r* [ansi( h, Name )]: 
	The name of the place, better if lower-case except for proper nouns or 
	Victorianization. (default: a table)%r* [ansi( h, Spaces )]: The number of 
	spaces at a place. If set to '0', there is no limitation. (default: 4)%r* 
	[ansi( h, Description )]: The description of the place. (default: A table 
	with a couple of chairs.)%r* [ansi( h, Say_Prefix )]: What's added to the 
	use of 'tt' or 'tto' at that place. A comma is automatically added. 
	(default: At your table)%r* [ansi( h, Join )]: What a player sees when they 
	join the place. (default: You join #NAME.)%r* [ansi( h, Ojoin )]: What 
	people not at that place when someone joins, prefixed by the joiner's name. 
	(default: joins #NAME (##LOC).)%r* [ansi( h, Depart )]: What a player sees 
	when they depart the place. (default: You depart #NAME.)%r* [ansi( h, 
	Odepart )]: What people not at that place when someone departs, prefixed by 
	the departer's name. (default: departs #NAME (##LOC).)%r%r%% [ansi( h, 
	Tokens )]%rThere are some tokens which the system will replace for the 
	<value> of Say_Prefix, Join, Ojoin, Depart, and Odepart. More tokens can be 
	added by player request.%r%r* [ansi( h, #NAME )]: The name of the place.%r* 
	[ansi( h, #LCNAME )]: The name, forced lower-case.%r* [ansi( h, #LOC )]: The 
	number of the place.%r%rFor examples, see: [ansi( h, +help places 5 
	)]~[ansi( h, places() )]%r%rThere is a single function, places(), that gives 
	access to most of this in a raw form. Because of its privileged nature, it 
	will be locked down to limitations such as only being usable in the room or 
	by the owner. Staff is given the ability to bypass all limitations.%r%rHere 
	would be a great place to explain it.~[ansi( h, Usage Examples )]%r%r* 
	Basics%r%rplaces: When you first enter a room that announces it has 
	places.%rjoin 3: I want to join the place numbered '3'%rjoin Anderson: I 
	want to join wherever Anderson is.%rtt Hello!: Say "Hello!" to everyone at 
	that place.%rtto Is this going to turn into combat?: Say "Is this going to 
	turn into combat?" OOCly at that place.%rdepart: Leave that place%r%r* 
	Frills%rtt |Someone's knee jams up against the table.: Emit "Someone's knee 
	jams up against the table." to everyone at that place.%rplaces/cleanup: Make 
	sure that the only people you see when you type 'places' are people who are 
	actually there.%r%r[ansi( h, Administration Examples )]%r%r* Configuring 
	Places%r%rplaces/configure here/5: Set up 5 places here, all with the 
	defaults.%rplaces/set 1/name=merry-go-round: Place #1 will be named 
	'merry-go-round'.%rplaces/set 1/say=On the #NAME: Someone using 'tt <text>' 
	there will say it as: On the merry-go-round, <name> says 
	"<text>"%rplaces/breakdown: Remove the places system from this room.%r%r* 
	Altering Places%rplaces/delplace 4: Delete place #4.%rplaces/compress: 
	Compress it so Place #5 is now Place #4.%rplace/newplace: Create a new place 
	to the next available place ( #5 in this example ).%rplace/newplace 10: 
	Create a new place numbered '10' at your current location.%r%r* Staff 
	Frills%rplaces/configure <dbref>/5: Set up 5 places at 
	<dbref>.%rplaces/breakdown <dbref>: Remove the places system from 
	<dbref>.%rplaces/newplace <dbref>: Create a new place to the next available 
	place at <dbref>.~[ansi( h, Credits )]%r%rThis major overhaul of the SGP 
	places command was committed by Thenomain.


--------------------------------------------------------------------------------
-- Hardcode Version ------------------------------------------------------------

// This is for plushelp.txt



*/